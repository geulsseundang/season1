# 클린 아키텍처

톰 홈버그의 '만들면서 배우는 클린 아키텍처' 4장까지의 내용 중 인상 깊은 내용을 담았습니다.

클린 아키텍처는 계층형 아키텍처의 문제를 해결하기 위해 의존의 역전을 사용함으로써 도메인 문제에 집중하고, 코드를 변경할 이유의 수를 줄여 유지보수성을 높이는 방법을 제시했습니다.

이번에는 코드 상의 구현으로 어떻게 적용하면 되는지를 알아보도록 하겠습니다.

---

## 1. 유스케이스

![image](https://github.com/geulsseundang/season1/assets/44438366/edcc5f83-851a-4e30-81d3-48496162ca25)

육각형 아키텍처에서는 도메인 중심의 아키텍처에 적합하기 떄문에 도메인 엔티티를 만드는 것으로 시작한 후 해당 도메인 엔티티를 중심으로 유스케이스를 구현한다.

### 1.1. 유스케이스가 하는 일

1. 입력을 받는다.
   - 인커밍 어댑터로부터 입력을 받는다.
   - 도메인 로직에만 신경써야 하며 유효성 검증단계는 다른 곳에서 처리한다.
     - (유스케이스는 도메인 로직에만 신경써야 하고, 입력 유효성 검증으로 오염되면 안된다.)
2. 비즈니스 규칙을 검증한다.
   - 유효성 검증이 아니라 비즈니스 규칙을 검증할 책임이 있다.
   - 도메인 엔티티와 이 책임을 공유한다.
3. 모델 상태를 조작한다.
   - 입력을 기반으로 모델 상태를 변경한다.
   - 도메인 객체의 상태를 바꾸고, 영속성 어댑터를 통해 구현된 포트로 상태를 전달하여 저장될 수 있게 한다.
   - 또 다른 아웃고잉 어댑터를 호출할 수 있다.
4. 출력을 반환한다.
   - 아웃고잉 어댑터에서 온 출력값을 유스케이스를 호출한 어댑터로 반환할 출력 객체로 변환한다.

### 1.2. 입력 유효성 검증

유스케이스가 하는 일 중 1번을 설명하며 `유효성 검증은 다른 곳에서 처리`한다고 언급했는데, 여전히 이 작업은 애플리케이션 계층의 책임에 해당합니다. 애플리케이션 코어의 바깥쪽으로부터 유효하지 않은 입력값을 받게 되고, 모델의 상태를 해칠 수 있기 때문입니다.

하지만 유스케이스 클래스에서는 하지 않고, 입력 모델을 사용하여 처리합니다.

- 입력모델의 생성자 내에서 입력 유효성을 검증합니다.
- 조건 중 하나라고 위배되면 객체를 생성할 때 예외를 던져서 객체 생성을 막으면 됩니다.
- 이러한 도구가 이미 있는데, 자바 세계에서는 Bean Validation API가 표준 라이브러리다.
- 필드의 애너테이션으로 표현할 수 있다.
  - @NotNull

### 1.3. 유스케이스마다 다른 입력 모델

다른 유스케이스에 동일한 입력 모델을 사용하고 싶은 생각이 들 때가 있다. `계좌 등록하기`, `계좌 정보 업데이트하기` 를 보면 거의 똑같은 계좌 상세 정보가 필요하다. 차이점은 ID 이다. 불변 커맨드 객체의 필드에 대해서 null 을 유효한 상태로 받아들이는 것은 그 자체로 `코드 스멜`이다. 또한 이 때 유스케이스에 커스텀 유효성 검증 로직을 넣어야 하고, 이는 **비즈니스 코드를 입력 유효성 검증과 관련된 관심사로 오염**시킨다.

### 1.4. 비즈니스 규칙 검증하기

| -         | 입력 유효성 검증                  | 비즈니스 규칙                    |
| --------- | --------------------------------- | -------------------------------- |
| 구분점    | 도메인 모델의 현재 상태에 접근 X  | 도메인 모델의 현재 상태에 접근   |
| 구현 방법 | 선언적으로 구현 - ex) @NotNull    | 맥락이 필요                      |
| 의미      | 구문상의(syntactical) 유효성 검증 | 의미적인(semantical) 유효성 검증 |
| 구현 위치 | 생성자                            | 도메인 엔티티                    |

- 비즈니스 규칙 검증
  - 풍부한 도메인 모델: 도메인 엔티티 안에 넣으면, 위치를 정하는 것도 쉽고, 추론하기도 쉽다.
  - 빈약한 도메인 모델: 위 방법이 어렵다면, 유스케이스 코드에서 도메인 엔티티를 사용하기 전에 한다.
- 검증이 실패할 경우 유효성 검증 전용 예외를 던진다.
- 유스케이스마다 다른 출력 모델을 사용.
  - (단일 책임 원칙) + 모델 분리 = 유스케이스 결합 제거

### 1.5. 정리

> 입출력 모델을 독립적으로 모델링한다면, 유스케이스간 모델을 공유하는 것보다 더 많은 작업이 필요하지만
>
> 유스케이스를 명확히 이해할 수 있기 때문에 장기적으로 유지보수하기도 더 쉽다.
>
> 또한, 여러 명의 개발자가 다른 사람이 작업 중인 유스케이스를 건드리지 않은 채로 여러 개의 유스케이스를 동시에 작업할 수 있다.

## 2. 웹 어댑터 구현

우리가 목표로 하는 아키텍처에서 외부 세계와의 모든 커뮤니케이션은 어댑터를 통해 이뤄진다.
따라서 이번에는 웹 인터페이스를 제공하는 어댑터의 구현 방법을 살펴보자.

### 2.1. 의존의 역전

![image](https://github.com/geulsseundang/season1/assets/44438366/e56cd124-a03b-4379-beac-bbc55e6601a7)

웹 어댑터는 `주도하는` 혹은 `인커밍` 어댑터다.
왜 어댑터와 유스케이스 사이에 또 다른 간접 계층을 넣어야 할까?

- 애플리케이션 코어가 외부 세계와 통신할 수 있는 곳에 대한 명세가 포트이기 때문이다.
- 포트를 적절한 곳에 위치시키면 외부와 어떤 통신이 일어나고 있는지 정확히 알 수 있고, 이는 레거시 코드를 다루는 유지보수 엔지니어에게는 무척 소중한 정보다.
- 때에 따라 웹 어댑터는 인커밍 어댑터인 동시에 아웃고잉 어댑터가 된다. 한 어댑터가 동시에 두 가지 역할을 하지못할 이유는 없다.
- 그러나 이후 내용에서는 웹 어댑터가 일반적인 인커밍 어댑터 역할만 한다고 가정한다.

### 2.2. 웹 어댑터의 책임

1. HTTP 요청을 자바 객체로 매핑
2. 권한 검사
3. 입력 유효성 검증
4. 입력을 유스케이스의 입력 모델로 매핑
5. 유스케이스 호출
6. 유스케이스의 출력을 HTTP로 매핑
7. 유스케이스 호출
8. 유스케이스의 출력을 HTTP 로 매핑
9. HTTP 응답을 반환

웹 어댑터의 책임이 많다. 하지만 애플리케이션 계층이 신경쓰면 안 되는 것들이기도 하다. HTTP 와 관련된 것은 애플리케이션 계층으로 침투해서는 안된다.

- 다른 어댑터로 쉽게 교체할 수 있는 형식을 유지하기 위함

웹 어댑터와 애플리케이션 계층 간의 이 같은 경계는 도메인과 애플리케이션 계층부터 개발하기 시작하면 자연스럽게 생긴다. 유스케이스를 먼저 구현하면 경계를 흐리게 만들 유혹에 빠지지 않을 수 있다.

### 2.3. 컨트롤러 나누기

컨트롤러는 너무 적은 것보다는 너무 많은 게 낫다.

- 클래스마다 코드는 적을수록 좋다.
- 테스트 코드도 마찬가지다. 프로덕션 코드에 비해 파악하기가 어려울 때가 많기 떄문에 특정 프로덕션 코드에 해당하는 테스트 코드를 찾기 쉽게 만들어야 하고, 클래스가 작을수록 더 찾기가 쉽다.
- 모든 연산을 단일 컨트롤러에 넣는 것은 데이터 구조의 재활용을 촉진한다.
  - 필요 없는 필드가 존재하는 경우가 있어 헷갈릴 수 있다.
  - 그래서 각 연산에 대해 가급적 별도의 패키지 안에 별도의 컨트롤러를 만드는 방식을 선호한다.
- 서로 다른 연산에 대한 동시 작업이 쉬워진다.

### 2.4. 정리

> 작은 클래스들은 더 파악하기 쉽고, 테스트하기 쉽고, 동시 작업을 지원한다.

## 3. 영속성 어댑터 개발

영속성 계층을 애플리케이션 계층의 플러그인으로 만드는 방법을 살펴본다.

### 3.1. 의존성 역전

![image](https://github.com/geulsseundang/season1/assets/44438366/5df645cc-c904-45bf-836d-91f1c1add26d)

육각형 아키텍처에서 영속성 어댑터는 `주도되는` 혹은 `아웃고잉` 어댑터다. 애플리케이션에 의해 호출될 뿐, 애플리케이션을 호출하지는 않기 때문이다.

포트는 간접적인 계층이다. 영속성 계층의 코드 의존성을 없애기 위해 이러한 간접 계층을 추가하고 있다. 영속성 코드를 리팩터링하더라도 코어 코드는 변경되지 않는다.

### 3.2. 영속성 어댑터의 책임

1. 입력을 받는다.
   - 포트 인터페이스를 통해 입력을 받는다.
2. 입력을 데이터베이스 포맷으로 매핑한다.
   - 일반적으로 JPA(Java Persistence API)를 사용하기 떄문에 입력 모델을 데이터베이스 테이블 구조를 반영한 JPA 엔티티 객체로 매핑한다.
3. 입력을 데이터베이스로 보낸다.
   - 어떤 기술을 사용해도 상관없다.
   - 핵심은 영속성 어댑터의 입력 모델이 영속성 어댑터 내부에 있는 것이 아니라 애플리케이션 코어에 있기 때문에 영속성 어댑터 내부를 변경하는 것이 코어에 영향을 미치지 않는다는 것이다.
4. 데이터베이스 출력을 애플리케이션 포맷으로 매핑한다.
5. 출력을 반환한다.
   - 출력 모델이 영속성 어댑터가 아니라 애플리케이션 코어에 위치하는 것이 중요하다.

입출력 모델이 애플리케이션 코어에 있다는 점을 제외하면 책임은 전통적인 영속성 계층의 책임과 크게 다르지 않다.

### 3.3. 포트 인터페이스 나누기

데이터베이스 연산을 정의하고 있는 포트 인터페이스는 어떻게 나눌 것인가?

특정 엔티티가 필요하는 모든 데이터베이스 연산을 하나의 리포지토리 인터페이스 안에 넣어 두는 게 일반적인 방법이다.

- 넓은 포트 인터페이스에 의존성을 갖게 된다.
- 불필요한 의존이 생겼다는 의미
- 맥락 안에서 불필요한 메서드에 생긴 의존성은 코드를 이해하고 테스트하기 어렵게 한다.

→ 인터페이스 분리 원칙(Interface Segregation Principle, ISP)이 답을 제시한다.

- 클라이언트가 오로지 자신이 필요하는 메서드만 알면 되도록 넓은 인터페이스를 특화한 인터페이스로 분리해야 한다.
- 각 서비스는 실제로 필요한 메서드에만 의존한다. 포트의 이름이 포트의 역할을 명확히 잘 표현한다. -매우 좁은 포트를 만드는 것은 코딩을 `플러그 앤드 플레이(plug-and-play)`경험으로 만든다.

### 3.4. 데이터베이스 트랜잭션은 어떻게 해야 할까?

영속성 어댑터는 어떤 데이터베이스 연산이 같은 유스케이스에 포함되는지 알지 못하기 떄문에 언제 트랜잭션을 열고 닫을지 결정할 수 없다.
이 책임은 영속성 어댑터 호출을 관장하는 서비스에 위임해야 한다.

- @Transactional
- AOP

### 3.5. 정리

> 도메인 코드에 플러그인처럼 동작하는 영속성 어댑터를 만들면 도메인 코드가 영속성과 관련된 것들로부터 분리되어 풍부한 도메인 모델을 만들 수 있다.
>
> 좁은 포트 인터페이스를 사용하면 포트마다 다른 방식으로 구현할 수 있는 유연함이 생긴다. 심지어 포트 뒤에 애플리케이션 모르게 다른 영속성 기술을 사용할 수 있다.
> 포트의 명세만 지켜진다면 영속성 계층 전략을 교체할 수 있다.
